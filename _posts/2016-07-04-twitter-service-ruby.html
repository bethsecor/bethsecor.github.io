---
title: Twitter Service in Rails from Scratch
layout: post
date: 2016-07-04
---

<p>
  Last week I received a code challenge: use whatever technologies you like, but use the Twitter API! I decided to use Rails, because well, I love working in Rails and am most comfortable with it. I've used the Twitter API before in a past project, but used the <code>twitter</code> gem. This time, I decided to challenge myself and show that I could read through the documentation and build a service that would authorize a request. I did, however, decide to use the <code>omniauth-twitter</code> gem for OAuth, so that I could jump into accessing an endpoint with the user's token (this was a timed challenge).
</p>

<p>
  Since I could do anything with Twitter, I decided to make a fun little app where a user could login and see an exhibit of all of their friends' banners. I needed to authorize the GET friends/list endpoint. The params weren't difficult for this request, but the Authorization header was definitely tricky.
</p>

<p>
  Before coding anything in the service, I sat there and just read the <a href="https://dev.twitter.com/oauth/overview/authorizing-requests">documentation for authorizing a request</a> a few times to wrap my head around it. Then, the way I like to code is to write the method names that I wish I had, and then go ahead and fill those in. To start, I needed to initialize the Twitter service with the current user (I needed to use their ID and token) and the connection to the Twitter API. The <code>friends</code> method would return an array of all the user's friends' info.
</p>

<p>
  Since the Authorization header was going to involve a lot, I wanted that to be it's own method (<code>friend_header</code>). It returns a hash of all the key-value pairs needed for the header, and creates the timestamp and the nonce. The timestamp is pretty self explanatory, and the nonce is just a jumble of random alphanumeric characters that can nicely be acheived by Ruby's <code>SecureRandom.hex</code>.
</p>

<p>
  For the <code>oauth_consumer_key</code>, you'll notice it's getting that from an environment variable <code>TWITTER_ID</code>. I'm using the gem <code>figaro</code> here to keep my keys secret.
</p>

<p>
  Now for the signature piece! I needed to pass in the timestamp and the nonce because I didn't want to initiate new ones, that would have caused the request to fail. You can read the documentation for creating signatures <a href="https://dev.twitter.com/oauth/overview/creating-signatures">here</a>. The signature uses HMAC-SHA1. SHA1 is the hash function, which produces a message digest, given a key and the original message. Luckily, Ruby has a module <code>OpenSSL::HMAC</code> that will do all of this for us. Twitter refers to the key as the signing key, which is a string of the percent encoded secret application API key and the percent encoded user's secret key. An example of percent encoding: a dash "-" in a string becomes "%2D". To achieve this in Ruby I used <code>CGI.escape</code>.
</p>

<p>
  The message, or base string, is a combination of the HTTP method, the percent encoded base URL, and the percent encoded value of all the parameters and authorization headers in alphabetical order (excluding the signature of course). I'll admit that <code>friends_base_string</code> is not the cleanest code, and I should have had a more generalized method in which I pass in the parameters and headers and it sorts them alphabetically. At this point, I just wanted to make things work, so I moved on.
</p>

<p>
  Okay! So now we have the base string and the signing key, we feed those into <code>OpenSSL::HMAC.digest</code>, and we get a binary string. Twitter tells us we need to convert this to base64, so I used Ruby's <code>Base64.encode64</code>. This usually leaves us with a newline at the end, so we chomp that off, and just to be safe, gsub any other newlines anywhere else. Now we take that base64 string and percent encode it, and it's ready to go to our Authorization header!
</p>

<p>
  The Authorization header needs to begin with "OAuth" followed by each key in quotes, then ":", then the value in quotes, which is what <code>friend_header_string</code> does.
</p>

<p>
  Now, <code>friends</code> has everything it needs, Faraday will return the response that needs to be parsed, so I have a little method for that that uses <code>JSON.parse</code>. If the response was successful, it should have a key <code>:users</code>, if not, just return an empty array. With more time, it would probably be better to handle errors differently, but this works for now.
</p>

<script src="https://gist.github.com/bethsecor/c93198c1e84f27b9c25cfb998d831782.js"></script>

<p>
  I call this <code>TwitterService</code> in a psuedo Rails model <code>Friend</code> (no need to inherit from <code>ActiveRecord::Base</code>). In <code>get_friends</code> I turn each friend into an open struct ruby object so that it's cleaner to work with in the views. That way also, if I ever decide to store this info in the database, the view won't have to change as much.
</p>

<script src="https://gist.github.com/bethsecor/9409293c6a60ae9a3808d0a234e11c8b.js"></script>

<p>
  For the full project code, <a href="https://github.com/bethsecor/twitter-client-everlane">check it out here</a>.
</p>
